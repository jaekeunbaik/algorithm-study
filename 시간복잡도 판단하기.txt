- 6) 시간 복잡도란?
    
    > “입력값에 비해 얼마나 일을 수행해야 하는가?”
    > 
    
    가 시간 복잡도입니다.
    
    예를 들어서 내가 반에 있는 사람들 중에서 가장 이성에게 호감이 높은 사람을 뽑는다고 해볼게요.
    
    반에 있는 사람들이 N명이라고 한다면
    
    A 방식은 N 번 만큼의 연산이 필요하고
    
    B 방식은 N^2 만큼의 연산이 필요하다고 할게요.
    
    N 이 예를 들어서 30이라면 A 방식은 30번, B 방식은 900 번의 연산이 필요하겠죠
    
    <aside>
    💡 시간복잡도는 입력값과 문제를 해결하는 데 걸리는 시간과의 상관관계를 말합니다! 
    
    입력값이 2배로 늘어났을 때 문제를 해결하는 데 걸리는 시간은 몇 배로 늘어나는지를 보는 것이죠.
    우리는 시간이 적게 걸리는 알고리즘을 좋아하니 입력값이 늘어나도 걸리는 시간이 덜 늘어나는 알고리즘이 좋은 알고리즘이겠죠?
    
    
- 7) 최댓값 찾기 알고리즘의 시간 복잡도 판단해보기
    - 첫 번째 방법
        
        ```python
        def find_max_num(array):
            for number in array:
                is_max_num = True
                for compare_number in array:
                    if number < compare_number:
                        is_max_num = False
                if is_max_num:
                    return number
        
        print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
        print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
        print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))
        ```
        
        - 이 해결 방법은 각 숫자마다 모든 다른 숫자와 비교해서 최대값인지 확인합니다. 만약 다른 모든 값보다 크다면 반복문을 중단합니다.
        - 이 함수가 시간이 얼마나 걸리는지 어떻게 분석할 수 있을까요?
        - 바로, **각 줄이 실행되는 걸 1번의 연산이 된다**고 생각하고 계산하시면 됩니다. 아래와 같이 계산할 수 있습니다.
        
        ```python
            for number in array:                 # array 의 길이만큼 아래 연산이 실행
                for compare_number in array:     # array 의 길이만큼 아래 연산이 실행
                    if number < compare_number:  # 비교 연산 1번 실행
                        is_max_num = False       # 대입 연산 1번 실행
                if is_max_num:                   # 비교 연산 1번 실행
                    return number
        ```
        
        - 위에서 연산된 것들을 더해보면,
            1. array의 길이 X array의 길이 X (비교 연산 1번 + 대입 연산 1번)
            
            만큼의 시간이 필요합니다. 여기서 array(입력값)의 길이는 보통 N이라고 표현합니다. 그러면 위의 시간을 다음과 같이 표현할 수 있습니다.
            
            $$
            N \times N \times 2
            $$
            
            1. array의 길이 X 비교 연산 1번
            
            만큼의 시간이 필요합니다. 
            
            $$
            N
            $$
            
            그러면 우리는 이제 이 함수는 $2* N^2 + N$ 만큼의 **시간이 걸렸겠구나**! 라고 말할 수 있습니다.
            
            ❓ **Q.** 선생님 여기서 입력값이 뭔가요?
            **A.** 함수에서 크기가 변경될 수 있는 값이라고 보시면 됩니다! 
            배열을 받고 있으니 이 함수에서는 배열이 입력값입니다.
            
            **Q.** 선생님 그러면 여기서 N 이 6이니까, 78이라고 말하면 안되나요?
            **A.** N 의 크기에 따른 시간의 상관관계를 시간복잡도라고 하는 것이라 수식으로 표현하셔야 합니다!
            
            
    - 두 번째 방법
        
        ```python
        def find_max_num(array):
            max_num = array[0]        
            for num in array:      
                if num > max_num:  
                    max_num = num
            return max_num
        
        print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
        print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
        print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))
        ```
        
        - 이 해결 방법은 리스트를 하나씩 돌면서 num 과 max_num 값을 비교하는 함수입니다.
        - 다시 한 번 시간복잡도를 분석해볼까요?
        
        ```python
            max_num = array[0] # 연산 1번 실행
        ```
        
        ```python
        		for num in array:      # array 의 길이만큼 아래 연산이 실행
        		    if num > max_num:  # 비교 연산 1번 실행
        		        max_num = num  # 대입 연산 1번 실행
        ```
        
        - 위에서 연산된 것들을 더해보면,
            1. max_num 대입 연산 1번
            2. array의 길이 X (비교 연산 1번 + 대입 연산 1번) 
            
            만큼의 시간이 필요합니다. 첫 번째 방법에서 했던 것처럼 array 의 길이를 N이라고 하면, 다음과 같이 표현할 수 있겠죠?
            
            $$
            1+2\times N
            $$
            
            그러면 우리는 이제 이 함수는 $2N+1$ 만큼의 **시간이 걸렸겠구나**! 라고 말할 수 있습니다.
            
    - 비교하기
        - 코드만 봐도 두 번째 방법이 좋을 것 같다고 어렴풋이 생각은 했겠지만, 이렇게 수치화시키니 얼마나 효율적인지 정량적으로 분석할 수 있습니다
        - 그러면, 이를 수학적으로 표현해보면 첫 번째 방법은 $2 * N^2 + N$, 두 번째 방법은 $2N+1$ 이라는 식이 나온다는 걸 알 수 있습니다. 그러면 N 의 길이가 길어질수록, 다음과 같이 연산량이 변화합니다.
        
        [2N^2 + N vs 2N+1](https://www.notion.so/428088f70a3e426a85e472f67afe571a?pvs=21)
        
        - 이 표를 보면, 두 가지를 깨달을 수 있습니다.
            1.  $N$ 과 $N^2$ 은 N 이 커질수록 더 큰 차이가 나는구나!
            2.  $N$의 지수를 먼저 비교하면 되겠구나.
        - 저희가 매번 코드를 매 실행 단위로 이렇게 몇 번의 연산이 발생하는지 확인하는 건 불가능합니다. 따라서 **상수는 신경쓰지말고**, 입력값에 비례해서 어느 정도로 증가하는지만 파악하면 됩니다.
        
        <aside>
        💡 즉,
        $2N^2 + N$ 의 연산량이 나온 첫번째 풀이 방법은 $N^2$ 만큼의 연산량이 필요하다.
        $2N+1$의 연산량이 나온 두번째 풀이 방법은 $N$ 만큼의 연산량이 필요하다
        
        참고로, 만약 상수의 연산량이 필요하다면, $1$ 만큼의 연산량이 필요하다고 말하면 됩니다.
        